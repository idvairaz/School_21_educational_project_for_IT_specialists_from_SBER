поместила, на всякий, сюда метод. что б не писать в след раз если понадобится.
 тут не зависим от s21matrix. можно использовать в других местах и языках
/**
 * @brief Вычисляет определитель квадратной матрицы.
 *
 * Этот метод использует рекурсивный подход для вычисления определителя матрицы размерности n.
 * Для матриц размерности 1 возвращает элемент матрицы, для матриц размерности 2 
 * вычисляет определитель по формуле ad - bc. Для матриц большего размера метод 
 * использует разложение по первой строке, создавая подматрицы и рекурсивно вычисляя 
 * их определители.
 *
 * @param matrix Указатель на двумерный массив, представляющий квадратную матрицу.
 * @param n Размерность квадратной матрицы (количество строк и столбцов).
 * @return Определитель матрицы в виде числа с плавающей запятой.
 *
 */
double determinant_recursive(double **matrix, int n) const {
    //  базовые случаи
    if (n == 1) {
        return matrix[0][0];
    }
    if (n == 2) {
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
    }

    double det = 0.0;
    for (int col = 0; col < n; col++) {
        // Создание подматрицы
        double **sub_matrix = new double*[n - 1];
        for (int i = 0; i < n - 1; ++i) {
            sub_matrix[i] = new double[n - 1];
        }

        for (int sub_i = 1; sub_i < n; sub_i++) {
            int sub_j = 0;
            for (int j = 0; j < n; j++) {
                if (j != col) {
                    sub_matrix[sub_i - 1][sub_j] = matrix[sub_i][j];
                    sub_j++;
                }
            }
        }

        // Рекурсивный вызов
        double sub_det = determinant_recursive(sub_matrix, n - 1);
        det += (col % 2 == 0 ? 1 : -1) * matrix[0][col] * sub_det;

        // Освобождение памяти для подматрицы
        for (int i = 0; i < n - 1; ++i) {
            delete[] sub_matrix[i];
        }
        delete[] sub_matrix;
    }

    return det;
}
